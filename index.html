<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Rainbowr55.GitHub.io by rainbowr55</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Rainbowr55.GitHub.io</h1>
        <h2>about java android js pythod git ...etc learning notes</h2>
        <a href="https://github.com/rainbowr55" class="button"><small>Follow me on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h3>
<a id="垃圾回收器有三大职责" class="anchor" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E4%B8%89%E5%A4%A7%E8%81%8C%E8%B4%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>垃圾回收器有三大职责:</h3>

<ul>
<li>分配内存;</li>
<li>确保任何被引用的对象保留在内存中;</li>
<li>回收不能通过引用关系找到的对象的内存. 
<img src="http://upload-images.jianshu.io/upload_images/851999-e93c3c96a9a1ba2b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gc process">
### Heap和Stack
Heap内存是指java运行环境用来分配给对象和JRE类的内存. 是应用的内存空间.
Stack内存是相对于线程Thread而言的, 它保存线程中方法中短期存在的变量值和对Heap中对象的引用等.
Stack内存, 顾名思义, 是类Stack方式, 总是后进先出(LIFO)的.
我们通常说的GC的针对Heap内存的. 因为Stack内存相当于是随用随销的.
####JVM使用分代式的内存管理方式, 将Heap分成三代 --- 新生代, 老一代, 持久代</li>
<li>小GC执行非常频繁, 而且速度特别快.
大GC一般会比小GC慢十倍以上.
大小GC都会发出"Stop the World"事件, 也就是说中断程序运行, 直至GC完成. 这也是我们在App优化之消除卡顿中为什么说频繁GC会造成用户感知卡顿.</li>
</ul>

<p><img src="http://upload-images.jianshu.io/upload_images/851999-675c33a31cc6208d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="head&amp;stack"></p>

<h3>
<a id="gc流程" class="anchor" href="#gc%E6%B5%81%E7%A8%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GC流程</h3>

<p><img src="http://upload-images.jianshu.io/upload_images/851999-16c831585c684eb8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

<h4>
<a id="当eden区域内存被分配完时-小gc程序被触发" class="anchor" href="#%E5%BD%93eden%E5%8C%BA%E5%9F%9F%E5%86%85%E5%AD%98%E8%A2%AB%E5%88%86%E9%85%8D%E5%AE%8C%E6%97%B6-%E5%B0%8Fgc%E7%A8%8B%E5%BA%8F%E8%A2%AB%E8%A7%A6%E5%8F%91" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>当Eden区域内存被分配完时, 小GC程序被触发:</h4>

<p><img src="http://upload-images.jianshu.io/upload_images/851999-ff339a2842dbfc41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

<h4>
<a id="引用可达的对象会移到survivor幸存者区域--s0-然后清空eden区域-此时引用不可达的对象会直接删除-内存回收" class="anchor" href="#%E5%BC%95%E7%94%A8%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BC%9A%E7%A7%BB%E5%88%B0survivor%E5%B9%B8%E5%AD%98%E8%80%85%E5%8C%BA%E5%9F%9F--s0-%E7%84%B6%E5%90%8E%E6%B8%85%E7%A9%BAeden%E5%8C%BA%E5%9F%9F-%E6%AD%A4%E6%97%B6%E5%BC%95%E7%94%A8%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BC%9A%E7%9B%B4%E6%8E%A5%E5%88%A0%E9%99%A4-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>引用可达的对象会移到Survivor(幸存者)区域--S0, 然后清空Eden区域, 此时引用不可达的对象会直接删除, 内存回收</h4>

<p><img src="http://upload-images.jianshu.io/upload_images/851999-3ccdda6d0fae500a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

<h4>
<a id="eden再次满时" class="anchor" href="#eden%E5%86%8D%E6%AC%A1%E6%BB%A1%E6%97%B6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Eden再次满时</h4>

<p>当Eden区域再次分配完后, 小GC执行, 引用可达的对象会移到Survivor(幸存者)区域, 而引用不可达的对象会跟随Eden的清空而删除回收.</p>

<p>需要注意的是, 这次引用可达的对象移动到的是S1的幸存者区.
而且, S0区域也会执行小GC, 将其中还引用可达的对象移动到S1区, 且年龄+1. 然后清空S0, 回收其中引用不可达的对象.</p>

<p>此时, 所有引用可达的对象都在S1区, 且S1区的对象存在不同的年龄</p>

<p><img src="http://upload-images.jianshu.io/upload_images/851999-bc737169e99d3d5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

<h4>
<a id="当eden第三次满时-s0和s1的角色互换了-依此循环" class="anchor" href="#%E5%BD%93eden%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%BB%A1%E6%97%B6-s0%E5%92%8Cs1%E7%9A%84%E8%A7%92%E8%89%B2%E4%BA%92%E6%8D%A2%E4%BA%86-%E4%BE%9D%E6%AD%A4%E5%BE%AA%E7%8E%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>当Eden第三次满时, S0和S1的角色互换了 依此循环</h4>

<p><img src="http://upload-images.jianshu.io/upload_images/851999-aca606170dba22b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

<h4>
<a id="当survivor区的对象年龄达到老年线时" class="anchor" href="#%E5%BD%93survivor%E5%8C%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E8%BE%BE%E5%88%B0%E8%80%81%E5%B9%B4%E7%BA%BF%E6%97%B6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>当Survivor区的对象年龄达到"老年线"时</h4>

<p>上面1~3循环, Survivor区的对象年龄也会持续增长, 当其中某些对象年龄达到"老年线", 例如8岁时, 它们会"晋升"到老年区.
<img src="http://upload-images.jianshu.io/upload_images/851999-9fb0b7b053c0a149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

<h4>
<a id="如此14步重复-大体流程是这样的" class="anchor" href="#%E5%A6%82%E6%AD%A414%E6%AD%A5%E9%87%8D%E5%A4%8D-%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>如此1~4步重复, 大体流程是这样的</h4>

<p><img src="http://upload-images.jianshu.io/upload_images/851999-70906ccc1aacef03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
        </section>

        <aside id="sidebar">


          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
